/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.8
 * apidoc:0.11.32 http://www.apidoc.me/gilt/svc-sundial/0.0.8/play_2_x_json
 */
package com.gilt.svc.sundial.v0.models {

  /**
   * A specification for when a process should be run
   */
  sealed trait ProcessSchedule

  sealed trait TaskExecutable

  case class ContinuousSchedule(
    bufferSeconds: _root_.scala.Option[Int] = None
  ) extends ProcessSchedule

  /**
   * See http://quartz-scheduler.org/api/2.2.0/org/quartz/CronExpression.html
   */
  case class CronSchedule(
    dayOfWeek: String,
    month: String,
    dayOfMonth: String,
    hours: String,
    minutes: String
  ) extends ProcessSchedule

  case class DockerImageCommand(
    image: String,
    tag: String = "latest",
    command: Seq[String],
    memory: _root_.scala.Option[Int] = None,
    cpu: _root_.scala.Option[Int] = None,
    taskRoleArn: _root_.scala.Option[String] = None,
    logPaths: Seq[String] = Nil,
    environmentVariables: Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable] = Nil
  ) extends TaskExecutable

  case class EnvironmentVariable(
    variableName: String,
    value: String
  )

  case class LogEntry(
    logEntryId: _root_.java.util.UUID,
    when: _root_.org.joda.time.DateTime,
    source: String,
    message: String
  )

  case class MetadataEntry(
    metadataEntryId: _root_.java.util.UUID,
    when: _root_.org.joda.time.DateTime,
    key: String,
    value: String
  )

  case class Process(
    processId: _root_.java.util.UUID,
    processDefinitionName: String,
    startTime: _root_.org.joda.time.DateTime,
    status: com.gilt.svc.sundial.v0.models.ProcessStatus,
    task: Seq[com.gilt.svc.sundial.v0.models.Task]
  )

  /**
   * A grouping of related tasks that are run as a single unit on the same schedule
   */
  case class ProcessDefinition(
    processDefinitionName: String,
    paused: _root_.scala.Option[Boolean] = None,
    processDescription: _root_.scala.Option[String] = None,
    schedule: _root_.scala.Option[com.gilt.svc.sundial.v0.models.ProcessSchedule] = None,
    taskDefinitions: Seq[com.gilt.svc.sundial.v0.models.TaskDefinition],
    overlapAction: com.gilt.svc.sundial.v0.models.ProcessOverlapAction = com.gilt.svc.sundial.v0.models.ProcessOverlapAction.Wait,
    subscriptions: Seq[com.gilt.svc.sundial.v0.models.Subscription]
  )

  case class ShellScriptCommand(
    script: String,
    environmentVariables: _root_.scala.Option[Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable]] = None
  ) extends TaskExecutable

  /**
   * A subscription for process notifications
   */
  case class Subscription(
    name: String,
    email: String,
    notifyWhen: com.gilt.svc.sundial.v0.models.NotificationOptions = com.gilt.svc.sundial.v0.models.NotificationOptions.OnStateChangeAndFailures
  )

  case class Task(
    taskId: _root_.java.util.UUID,
    processId: _root_.java.util.UUID,
    processDefinitionName: String,
    taskDefinitionName: String,
    startTime: _root_.org.joda.time.DateTime,
    endTime: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    previousAttemptCount: Int,
    logEntries: Seq[com.gilt.svc.sundial.v0.models.LogEntry],
    metadataEntries: Seq[com.gilt.svc.sundial.v0.models.MetadataEntry],
    executionState: _root_.scala.Option[Seq[com.gilt.svc.sundial.v0.models.MetadataEntry]] = None,
    status: com.gilt.svc.sundial.v0.models.TaskStatus
  )

  /**
   * An individual task that runs as part of a process
   */
  case class TaskDefinition(
    taskDefinitionName: String,
    dependencies: Seq[com.gilt.svc.sundial.v0.models.TaskDependency],
    executable: com.gilt.svc.sundial.v0.models.TaskExecutable,
    maxAttempts: Int,
    maxRuntimeSeconds: _root_.scala.Option[Int] = None,
    backoffBaseSeconds: Int,
    backoffExponent: Double = 1.0,
    requireExplicitSuccess: Boolean
  )

  case class TaskDependency(
    taskDefinitionName: String,
    successRequired: Boolean = true
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ProcessSchedule, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   */
  case class ProcessScheduleUndefinedType(
    description: String
  ) extends ProcessSchedule

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union TaskExecutable, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   */
  case class TaskExecutableUndefinedType(
    description: String
  ) extends TaskExecutable

  sealed trait NotificationOptions

  object NotificationOptions {

    /**
     * Always notify when a process commpletes
     */
    case object Always extends NotificationOptions { override def toString = "always" }
    /**
     * Notify when a process fails
     */
    case object OnFailure extends NotificationOptions { override def toString = "on_failure" }
    /**
     * Notify when a process goes from succeeding to failing and vica versa
     */
    case object OnStateChange extends NotificationOptions { override def toString = "on_state_change" }
    /**
     * Notify when going from failing to succeeded and on each failure
     */
    case object OnStateChangeAndFailures extends NotificationOptions { override def toString = "on_state_change_and_failures" }
    /**
     * Never notify
     */
    case object Never extends NotificationOptions { override def toString = "never" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends NotificationOptions

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Always, OnFailure, OnStateChange, OnStateChangeAndFailures, Never)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): NotificationOptions = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[NotificationOptions] = byName.get(value.toLowerCase)

  }

  sealed trait ProcessOverlapAction

  object ProcessOverlapAction {

    /**
     * The process should wait until the currently running instance finishes
     */
    case object Wait extends ProcessOverlapAction { override def toString = "wait" }
    /**
     * The currently running process should be killed
     */
    case object Terminate extends ProcessOverlapAction { override def toString = "terminate" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends ProcessOverlapAction

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Wait, Terminate)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ProcessOverlapAction = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ProcessOverlapAction] = byName.get(value.toLowerCase)

  }

  sealed trait ProcessStatus

  object ProcessStatus {

    /**
     * The process has tasks currently executing
     */
    case object Running extends ProcessStatus { override def toString = "running" }
    /**
     * All of the process's tasks succeeded on its last run
     */
    case object Succeeded extends ProcessStatus { override def toString = "succeeded" }
    /**
     * At least one of the process's tasks failed on its last run
     */
    case object Failed extends ProcessStatus { override def toString = "failed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends ProcessStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Running, Succeeded, Failed)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ProcessStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ProcessStatus] = byName.get(value.toLowerCase)

  }

  sealed trait TaskStatus

  object TaskStatus {

    /**
     * The task is currently executing or awaiting backoff
     */
    case object Running extends TaskStatus { override def toString = "running" }
    /**
     * The task has irrevocably failed
     */
    case object Failed extends TaskStatus { override def toString = "failed" }
    /**
     * The task has succeeded without serious errors
     */
    case object Succeeded extends TaskStatus { override def toString = "succeeded" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends TaskStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Running, Failed, Succeeded)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaskStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaskStatus] = byName.get(value.toLowerCase)

  }

}

package com.gilt.svc.sundial.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import com.gilt.svc.sundial.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsSvcSundialNotificationOptions = new play.api.libs.json.Reads[com.gilt.svc.sundial.v0.models.NotificationOptions] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.svc.sundial.v0.models.NotificationOptions] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.NotificationOptions(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.NotificationOptions(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialNotificationOptions(obj: com.gilt.svc.sundial.v0.models.NotificationOptions) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectNotificationOptions(obj: com.gilt.svc.sundial.v0.models.NotificationOptions) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialNotificationOptions: play.api.libs.json.Writes[NotificationOptions] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.NotificationOptions] {
        def writes(obj: com.gilt.svc.sundial.v0.models.NotificationOptions) = {
          jsonWritesSvcSundialNotificationOptions(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialProcessOverlapAction = new play.api.libs.json.Reads[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessOverlapAction(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessOverlapAction(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialProcessOverlapAction(obj: com.gilt.svc.sundial.v0.models.ProcessOverlapAction) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectProcessOverlapAction(obj: com.gilt.svc.sundial.v0.models.ProcessOverlapAction) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialProcessOverlapAction: play.api.libs.json.Writes[ProcessOverlapAction] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] {
        def writes(obj: com.gilt.svc.sundial.v0.models.ProcessOverlapAction) = {
          jsonWritesSvcSundialProcessOverlapAction(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialProcessStatus = new play.api.libs.json.Reads[com.gilt.svc.sundial.v0.models.ProcessStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.svc.sundial.v0.models.ProcessStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialProcessStatus(obj: com.gilt.svc.sundial.v0.models.ProcessStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectProcessStatus(obj: com.gilt.svc.sundial.v0.models.ProcessStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialProcessStatus: play.api.libs.json.Writes[ProcessStatus] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.ProcessStatus] {
        def writes(obj: com.gilt.svc.sundial.v0.models.ProcessStatus) = {
          jsonWritesSvcSundialProcessStatus(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialTaskStatus = new play.api.libs.json.Reads[com.gilt.svc.sundial.v0.models.TaskStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.svc.sundial.v0.models.TaskStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.TaskStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.TaskStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialTaskStatus(obj: com.gilt.svc.sundial.v0.models.TaskStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaskStatus(obj: com.gilt.svc.sundial.v0.models.TaskStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialTaskStatus: play.api.libs.json.Writes[TaskStatus] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.TaskStatus] {
        def writes(obj: com.gilt.svc.sundial.v0.models.TaskStatus) = {
          jsonWritesSvcSundialTaskStatus(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialContinuousSchedule: play.api.libs.json.Reads[ContinuousSchedule] = {
      (__ \ "buffer_seconds").readNullable[Int].map { x => new ContinuousSchedule(bufferSeconds = x) }
    }

    def jsObjectContinuousSchedule(obj: com.gilt.svc.sundial.v0.models.ContinuousSchedule) = {
      (obj.bufferSeconds match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("buffer_seconds" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonReadsSvcSundialCronSchedule: play.api.libs.json.Reads[CronSchedule] = {
      (
        (__ \ "day_of_week").read[String] and
        (__ \ "month").read[String] and
        (__ \ "day_of_month").read[String] and
        (__ \ "hours").read[String] and
        (__ \ "minutes").read[String]
      )(CronSchedule.apply _)
    }

    def jsObjectCronSchedule(obj: com.gilt.svc.sundial.v0.models.CronSchedule) = {
      play.api.libs.json.Json.obj(
        "day_of_week" -> play.api.libs.json.JsString(obj.dayOfWeek),
        "month" -> play.api.libs.json.JsString(obj.month),
        "day_of_month" -> play.api.libs.json.JsString(obj.dayOfMonth),
        "hours" -> play.api.libs.json.JsString(obj.hours),
        "minutes" -> play.api.libs.json.JsString(obj.minutes)
      )
    }

    implicit def jsonReadsSvcSundialDockerImageCommand: play.api.libs.json.Reads[DockerImageCommand] = {
      (
        (__ \ "image").read[String] and
        (__ \ "tag").read[String] and
        (__ \ "command").read[Seq[String]] and
        (__ \ "memory").readNullable[Int] and
        (__ \ "cpu").readNullable[Int] and
        (__ \ "taskRoleArn").readNullable[String] and
        (__ \ "log_paths").read[Seq[String]] and
        (__ \ "environment_variables").read[Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable]]
      )(DockerImageCommand.apply _)
    }

    def jsObjectDockerImageCommand(obj: com.gilt.svc.sundial.v0.models.DockerImageCommand) = {
      play.api.libs.json.Json.obj(
        "image" -> play.api.libs.json.JsString(obj.image),
        "tag" -> play.api.libs.json.JsString(obj.tag),
        "command" -> play.api.libs.json.Json.toJson(obj.command),
        "log_paths" -> play.api.libs.json.Json.toJson(obj.logPaths),
        "environment_variables" -> play.api.libs.json.Json.toJson(obj.environmentVariables)
      ) ++ (obj.memory match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("memory" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.cpu match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cpu" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.taskRoleArn match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("taskRoleArn" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsSvcSundialEnvironmentVariable: play.api.libs.json.Reads[EnvironmentVariable] = {
      (
        (__ \ "variable_name").read[String] and
        (__ \ "value").read[String]
      )(EnvironmentVariable.apply _)
    }

    def jsObjectEnvironmentVariable(obj: com.gilt.svc.sundial.v0.models.EnvironmentVariable) = {
      play.api.libs.json.Json.obj(
        "variable_name" -> play.api.libs.json.JsString(obj.variableName),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesSvcSundialEnvironmentVariable: play.api.libs.json.Writes[EnvironmentVariable] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.EnvironmentVariable] {
        def writes(obj: com.gilt.svc.sundial.v0.models.EnvironmentVariable) = {
          jsObjectEnvironmentVariable(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialLogEntry: play.api.libs.json.Reads[LogEntry] = {
      (
        (__ \ "log_entry_id").read[_root_.java.util.UUID] and
        (__ \ "when").read[_root_.org.joda.time.DateTime] and
        (__ \ "source").read[String] and
        (__ \ "message").read[String]
      )(LogEntry.apply _)
    }

    def jsObjectLogEntry(obj: com.gilt.svc.sundial.v0.models.LogEntry) = {
      play.api.libs.json.Json.obj(
        "log_entry_id" -> play.api.libs.json.JsString(obj.logEntryId.toString),
        "when" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.when)),
        "source" -> play.api.libs.json.JsString(obj.source),
        "message" -> play.api.libs.json.JsString(obj.message)
      )
    }

    implicit def jsonWritesSvcSundialLogEntry: play.api.libs.json.Writes[LogEntry] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.LogEntry] {
        def writes(obj: com.gilt.svc.sundial.v0.models.LogEntry) = {
          jsObjectLogEntry(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialMetadataEntry: play.api.libs.json.Reads[MetadataEntry] = {
      (
        (__ \ "metadata_entry_id").read[_root_.java.util.UUID] and
        (__ \ "when").read[_root_.org.joda.time.DateTime] and
        (__ \ "key").read[String] and
        (__ \ "value").read[String]
      )(MetadataEntry.apply _)
    }

    def jsObjectMetadataEntry(obj: com.gilt.svc.sundial.v0.models.MetadataEntry) = {
      play.api.libs.json.Json.obj(
        "metadata_entry_id" -> play.api.libs.json.JsString(obj.metadataEntryId.toString),
        "when" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.when)),
        "key" -> play.api.libs.json.JsString(obj.key),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesSvcSundialMetadataEntry: play.api.libs.json.Writes[MetadataEntry] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.MetadataEntry] {
        def writes(obj: com.gilt.svc.sundial.v0.models.MetadataEntry) = {
          jsObjectMetadataEntry(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialProcess: play.api.libs.json.Reads[Process] = {
      (
        (__ \ "process_id").read[_root_.java.util.UUID] and
        (__ \ "process_definition_name").read[String] and
        (__ \ "start_time").read[_root_.org.joda.time.DateTime] and
        (__ \ "status").read[com.gilt.svc.sundial.v0.models.ProcessStatus] and
        (__ \ "task").read[Seq[com.gilt.svc.sundial.v0.models.Task]]
      )(Process.apply _)
    }

    def jsObjectProcess(obj: com.gilt.svc.sundial.v0.models.Process) = {
      play.api.libs.json.Json.obj(
        "process_id" -> play.api.libs.json.JsString(obj.processId.toString),
        "process_definition_name" -> play.api.libs.json.JsString(obj.processDefinitionName),
        "start_time" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.startTime)),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "task" -> play.api.libs.json.Json.toJson(obj.task)
      )
    }

    implicit def jsonWritesSvcSundialProcess: play.api.libs.json.Writes[Process] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.Process] {
        def writes(obj: com.gilt.svc.sundial.v0.models.Process) = {
          jsObjectProcess(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialProcessDefinition: play.api.libs.json.Reads[ProcessDefinition] = {
      (
        (__ \ "process_definition_name").read[String] and
        (__ \ "paused").readNullable[Boolean] and
        (__ \ "process_description").readNullable[String] and
        (__ \ "schedule").readNullable[com.gilt.svc.sundial.v0.models.ProcessSchedule] and
        (__ \ "task_definitions").read[Seq[com.gilt.svc.sundial.v0.models.TaskDefinition]] and
        (__ \ "overlap_action").read[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] and
        (__ \ "subscriptions").read[Seq[com.gilt.svc.sundial.v0.models.Subscription]]
      )(ProcessDefinition.apply _)
    }

    def jsObjectProcessDefinition(obj: com.gilt.svc.sundial.v0.models.ProcessDefinition) = {
      play.api.libs.json.Json.obj(
        "process_definition_name" -> play.api.libs.json.JsString(obj.processDefinitionName),
        "task_definitions" -> play.api.libs.json.Json.toJson(obj.taskDefinitions),
        "overlap_action" -> play.api.libs.json.JsString(obj.overlapAction.toString),
        "subscriptions" -> play.api.libs.json.Json.toJson(obj.subscriptions)
      ) ++ (obj.paused match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("paused" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.processDescription match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("process_description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.schedule match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("schedule" -> jsObjectProcessSchedule(x))
      })
    }

    implicit def jsonWritesSvcSundialProcessDefinition: play.api.libs.json.Writes[ProcessDefinition] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.ProcessDefinition] {
        def writes(obj: com.gilt.svc.sundial.v0.models.ProcessDefinition) = {
          jsObjectProcessDefinition(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialShellScriptCommand: play.api.libs.json.Reads[ShellScriptCommand] = {
      (
        (__ \ "script").read[String] and
        (__ \ "environment_variables").readNullable[Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable]]
      )(ShellScriptCommand.apply _)
    }

    def jsObjectShellScriptCommand(obj: com.gilt.svc.sundial.v0.models.ShellScriptCommand) = {
      play.api.libs.json.Json.obj(
        "script" -> play.api.libs.json.JsString(obj.script)
      ) ++ (obj.environmentVariables match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("environment_variables" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonReadsSvcSundialSubscription: play.api.libs.json.Reads[Subscription] = {
      (
        (__ \ "name").read[String] and
        (__ \ "email").read[String] and
        (__ \ "notifyWhen").read[com.gilt.svc.sundial.v0.models.NotificationOptions]
      )(Subscription.apply _)
    }

    def jsObjectSubscription(obj: com.gilt.svc.sundial.v0.models.Subscription) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "email" -> play.api.libs.json.JsString(obj.email),
        "notifyWhen" -> play.api.libs.json.JsString(obj.notifyWhen.toString)
      )
    }

    implicit def jsonWritesSvcSundialSubscription: play.api.libs.json.Writes[Subscription] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.Subscription] {
        def writes(obj: com.gilt.svc.sundial.v0.models.Subscription) = {
          jsObjectSubscription(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTask: play.api.libs.json.Reads[Task] = {
      (
        (__ \ "task_id").read[_root_.java.util.UUID] and
        (__ \ "process_id").read[_root_.java.util.UUID] and
        (__ \ "process_definition_name").read[String] and
        (__ \ "task_definition_name").read[String] and
        (__ \ "start_time").read[_root_.org.joda.time.DateTime] and
        (__ \ "end_time").readNullable[_root_.org.joda.time.DateTime] and
        (__ \ "previous_attempt_count").read[Int] and
        (__ \ "log_entries").read[Seq[com.gilt.svc.sundial.v0.models.LogEntry]] and
        (__ \ "metadata_entries").read[Seq[com.gilt.svc.sundial.v0.models.MetadataEntry]] and
        (__ \ "execution_state").readNullable[Seq[com.gilt.svc.sundial.v0.models.MetadataEntry]] and
        (__ \ "status").read[com.gilt.svc.sundial.v0.models.TaskStatus]
      )(Task.apply _)
    }

    def jsObjectTask(obj: com.gilt.svc.sundial.v0.models.Task) = {
      play.api.libs.json.Json.obj(
        "task_id" -> play.api.libs.json.JsString(obj.taskId.toString),
        "process_id" -> play.api.libs.json.JsString(obj.processId.toString),
        "process_definition_name" -> play.api.libs.json.JsString(obj.processDefinitionName),
        "task_definition_name" -> play.api.libs.json.JsString(obj.taskDefinitionName),
        "start_time" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.startTime)),
        "previous_attempt_count" -> play.api.libs.json.JsNumber(obj.previousAttemptCount),
        "log_entries" -> play.api.libs.json.Json.toJson(obj.logEntries),
        "metadata_entries" -> play.api.libs.json.Json.toJson(obj.metadataEntries),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.endTime match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("end_time" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.executionState match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("execution_state" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesSvcSundialTask: play.api.libs.json.Writes[Task] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.Task] {
        def writes(obj: com.gilt.svc.sundial.v0.models.Task) = {
          jsObjectTask(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTaskDefinition: play.api.libs.json.Reads[TaskDefinition] = {
      (
        (__ \ "task_definition_name").read[String] and
        (__ \ "dependencies").read[Seq[com.gilt.svc.sundial.v0.models.TaskDependency]] and
        (__ \ "executable").read[com.gilt.svc.sundial.v0.models.TaskExecutable] and
        (__ \ "max_attempts").read[Int] and
        (__ \ "max_runtime_seconds").readNullable[Int] and
        (__ \ "backoff_base_seconds").read[Int] and
        (__ \ "backoff_exponent").read[Double] and
        (__ \ "require_explicit_success").read[Boolean]
      )(TaskDefinition.apply _)
    }

    def jsObjectTaskDefinition(obj: com.gilt.svc.sundial.v0.models.TaskDefinition) = {
      play.api.libs.json.Json.obj(
        "task_definition_name" -> play.api.libs.json.JsString(obj.taskDefinitionName),
        "dependencies" -> play.api.libs.json.Json.toJson(obj.dependencies),
        "executable" -> jsObjectTaskExecutable(obj.executable),
        "max_attempts" -> play.api.libs.json.JsNumber(obj.maxAttempts),
        "backoff_base_seconds" -> play.api.libs.json.JsNumber(obj.backoffBaseSeconds),
        "backoff_exponent" -> play.api.libs.json.JsNumber(obj.backoffExponent),
        "require_explicit_success" -> play.api.libs.json.JsBoolean(obj.requireExplicitSuccess)
      ) ++ (obj.maxRuntimeSeconds match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max_runtime_seconds" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesSvcSundialTaskDefinition: play.api.libs.json.Writes[TaskDefinition] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.TaskDefinition] {
        def writes(obj: com.gilt.svc.sundial.v0.models.TaskDefinition) = {
          jsObjectTaskDefinition(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTaskDependency: play.api.libs.json.Reads[TaskDependency] = {
      (
        (__ \ "task_definition_name").read[String] and
        (__ \ "success_required").read[Boolean]
      )(TaskDependency.apply _)
    }

    def jsObjectTaskDependency(obj: com.gilt.svc.sundial.v0.models.TaskDependency) = {
      play.api.libs.json.Json.obj(
        "task_definition_name" -> play.api.libs.json.JsString(obj.taskDefinitionName),
        "success_required" -> play.api.libs.json.JsBoolean(obj.successRequired)
      )
    }

    implicit def jsonWritesSvcSundialTaskDependency: play.api.libs.json.Writes[TaskDependency] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.TaskDependency] {
        def writes(obj: com.gilt.svc.sundial.v0.models.TaskDependency) = {
          jsObjectTaskDependency(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialProcessSchedule: play.api.libs.json.Reads[ProcessSchedule] = {
      (
        (__ \ "cron_schedule").read(jsonReadsSvcSundialCronSchedule).asInstanceOf[play.api.libs.json.Reads[ProcessSchedule]]
        orElse
        (__ \ "continuous_schedule").read(jsonReadsSvcSundialContinuousSchedule).asInstanceOf[play.api.libs.json.Reads[ProcessSchedule]]
        orElse
        play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessScheduleUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[ProcessSchedule]]
      )
    }

    def jsObjectProcessSchedule(obj: com.gilt.svc.sundial.v0.models.ProcessSchedule) = {
      obj match {
        case x: com.gilt.svc.sundial.v0.models.CronSchedule => play.api.libs.json.Json.obj("cron_schedule" -> jsObjectCronSchedule(x))
        case x: com.gilt.svc.sundial.v0.models.ContinuousSchedule => play.api.libs.json.Json.obj("continuous_schedule" -> jsObjectContinuousSchedule(x))
        case x: com.gilt.svc.sundial.v0.models.ProcessScheduleUndefinedType => sys.error(s"The type[com.gilt.svc.sundial.v0.models.ProcessScheduleUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialProcessSchedule: play.api.libs.json.Writes[ProcessSchedule] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.ProcessSchedule] {
        def writes(obj: com.gilt.svc.sundial.v0.models.ProcessSchedule) = {
          jsObjectProcessSchedule(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTaskExecutable: play.api.libs.json.Reads[TaskExecutable] = {
      (
        (__ \ "docker_image_command").read(jsonReadsSvcSundialDockerImageCommand).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
        orElse
        (__ \ "shell_script_command").read(jsonReadsSvcSundialShellScriptCommand).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
        orElse
        play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.TaskExecutableUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
      )
    }

    def jsObjectTaskExecutable(obj: com.gilt.svc.sundial.v0.models.TaskExecutable) = {
      obj match {
        case x: com.gilt.svc.sundial.v0.models.DockerImageCommand => play.api.libs.json.Json.obj("docker_image_command" -> jsObjectDockerImageCommand(x))
        case x: com.gilt.svc.sundial.v0.models.ShellScriptCommand => play.api.libs.json.Json.obj("shell_script_command" -> jsObjectShellScriptCommand(x))
        case x: com.gilt.svc.sundial.v0.models.TaskExecutableUndefinedType => sys.error(s"The type[com.gilt.svc.sundial.v0.models.TaskExecutableUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialTaskExecutable: play.api.libs.json.Writes[TaskExecutable] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.TaskExecutable] {
        def writes(obj: com.gilt.svc.sundial.v0.models.TaskExecutable) = {
          jsObjectTaskExecutable(obj)
        }
      }
    }
  }
}

package com.gilt.svc.sundial.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}
    import org.joda.time.{DateTime, LocalDate}
    import org.joda.time.format.ISODateTimeFormat
    import com.gilt.svc.sundial.v0.models._

    // Type: date-time-iso8601
    implicit val pathBindableTypeDateTimeIso8601 = new PathBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    implicit val queryStringBindableTypeDateTimeIso8601 = new QueryStringBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    // Type: date-iso8601
    implicit val pathBindableTypeDateIso8601 = new PathBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    implicit val queryStringBindableTypeDateIso8601 = new QueryStringBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    // Enum: NotificationOptions
    private[this] val enumNotificationOptionsNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${com.gilt.svc.sundial.v0.models.NotificationOptions.all.mkString(", ")}"

    implicit val pathBindableEnumNotificationOptions = new PathBindable.Parsing[com.gilt.svc.sundial.v0.models.NotificationOptions] (
      NotificationOptions.fromString(_).get, _.toString, enumNotificationOptionsNotFound
    )

    implicit val queryStringBindableEnumNotificationOptions = new QueryStringBindable.Parsing[com.gilt.svc.sundial.v0.models.NotificationOptions](
      NotificationOptions.fromString(_).get, _.toString, enumNotificationOptionsNotFound
    )

    // Enum: ProcessOverlapAction
    private[this] val enumProcessOverlapActionNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${com.gilt.svc.sundial.v0.models.ProcessOverlapAction.all.mkString(", ")}"

    implicit val pathBindableEnumProcessOverlapAction = new PathBindable.Parsing[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] (
      ProcessOverlapAction.fromString(_).get, _.toString, enumProcessOverlapActionNotFound
    )

    implicit val queryStringBindableEnumProcessOverlapAction = new QueryStringBindable.Parsing[com.gilt.svc.sundial.v0.models.ProcessOverlapAction](
      ProcessOverlapAction.fromString(_).get, _.toString, enumProcessOverlapActionNotFound
    )

    // Enum: ProcessStatus
    private[this] val enumProcessStatusNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${com.gilt.svc.sundial.v0.models.ProcessStatus.all.mkString(", ")}"

    implicit val pathBindableEnumProcessStatus = new PathBindable.Parsing[com.gilt.svc.sundial.v0.models.ProcessStatus] (
      ProcessStatus.fromString(_).get, _.toString, enumProcessStatusNotFound
    )

    implicit val queryStringBindableEnumProcessStatus = new QueryStringBindable.Parsing[com.gilt.svc.sundial.v0.models.ProcessStatus](
      ProcessStatus.fromString(_).get, _.toString, enumProcessStatusNotFound
    )

    // Enum: TaskStatus
    private[this] val enumTaskStatusNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${com.gilt.svc.sundial.v0.models.TaskStatus.all.mkString(", ")}"

    implicit val pathBindableEnumTaskStatus = new PathBindable.Parsing[com.gilt.svc.sundial.v0.models.TaskStatus] (
      TaskStatus.fromString(_).get, _.toString, enumTaskStatusNotFound
    )

    implicit val queryStringBindableEnumTaskStatus = new QueryStringBindable.Parsing[com.gilt.svc.sundial.v0.models.TaskStatus](
      TaskStatus.fromString(_).get, _.toString, enumTaskStatusNotFound
    )

  }

}